#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import logger_wrapper
import sys
import os


'''
Arquivo de configuração:

perfis:
  monico:
    empresaFuncionario: 49
    empresaFilial: 21
    filial: 1000
    bandeira: 1
    username: 60000723
    password: xxx
    scope: webclient
    grant_type: password
    canalVenda: ViaMais
    padrao: true
    ambientes:
      - prd:
          padrao: true

ambientes:
  - prd:
      url: http://api-jornada.casasbahia.net/uaa/oauth/token


A entrada "perfis" também é obrigatória, deve conter perfis válidos.
Os nomes dos perfis podem ser arbitrários, porém,dentro de um perfil é obrigatório existir as entradas 'padrao' e 'ambientes'. As demais são todas opcionais (mas sem elas o request de geração de token não vai funcionar).
A entrada "ambientes" é obrigatória. Porém pode estar vazia (nesse caso deve passar o parâmetro --ambiente.

O arquivo de configuração deve ficar localizado em $HOME/.config/viatoken/config.yaml
'''


def _log(level, message):
    print(f'[{level.upper()}]  {message}')

def _warn(message):
    _log('warn', message)

def _error(message, exit_code=1):
    _log('error', message)
    sys.exit(exit_code)


try:
    import requests
except ModuleNotFoundError:
    _error('Módulo "requests" não instalado', -1)


import shutil

if not shutil.which('xclip'):
    _error('Comando "xclip" não encontrado, finalizando...')


def parse_command_line():
    '''
    Reference: https://docs.python.org/3/library/argparse.html
    '''
    parser = argparse.ArgumentParser(
        description='Gera um token para o vendedor online')

    parser.add_argument('-p', '--profile', help='Perfil que será usado para logar no Via+')
    parser.add_argument('-u', '--url', help='URL onde a token será gerado')
    parser.add_argument('-e', '--environment', help='Seleciona o ambiente onde o token é gerado')
    parser.add_argument('--password', help='Override profile password')

    # TODO
    # parser.add_argument('--clipboard', help='Salva o token para a área de transferência')
    # parser.add_argument('--file', help='Salva o token para um arquivo')
    # parser.add_argument('--stdout', help='Imprime o token para a saída padrão')

    logger_wrapper.make_verbosity_argument(parser)

    return parser.parse_args()


def getConfigFile():
    return '{HOME}/.config/viatoken/config.yml'.format(**os.environ)


def getPerfilConfig(nome_perfil, configs):
    for nome, perfil in configs.get('perfis').items():
        if nome != nome_perfil and not perfil.get('padrao', False):
            continue

        if args.password:
            p = dict(perfil)
            p['password'] = args.password
            return p
        else:
            return perfil

    _error(f'Perfil não encontrado: {nome_perfil}')


def getAmbientePadrao(ambientes):
    # FIXME Se não existir uma entrada de ambientes no perfil selecionado, dá erro aqui
    for ambiente in ambientes:
        if isinstance(ambiente, dict):
            l = list(ambiente.items())
            if l[0][1].get('padrao', False):
                return l[0][0]

    return None


def getUrl(args, perfil_config, ambientes):
    if args.url:
        return args.url

    amb = args.environment or getAmbientePadrao(perfil_config.get('ambientes'))

    if not amb:
        raise Exception('"--amb" ou um ambiente padrão deve ser definido')

    for ambiente in ambientes:
        nome_ambientes = list(ambiente.keys())[0]

        if nome_ambientes == amb:
            return ambiente.get(amb).get('url')

    raise Exception('Ambiente não encontrado: "{}"', amb)


def getRequestArgs(args, configs):
    perfil_config = getPerfilConfig(args.profile, configs)

    url = getUrl(args, perfil_config, configs.get('ambientes'))

    body = dict(perfil_config)

    for amb in ['padrao', 'ambientes']:
        if amb in body:
            body.pop(amb)

    headers = {
        "Authorization": "Basic Y2xpZW50YXBwOnBhc3N3b3Jk",
    }

    return {
        "url": url,
        "data": body,
        "headers": headers,
        # TODO Gerar um certificado SSL
        "verify": False,
    }


def copy_to_clipboard(contents):
    from tempfile import TemporaryFile

    with TemporaryFile() as temp_file:
        temp_file.write(contents.encode())

        temp_file.seek(0)

        import subprocess

        process = subprocess.run('xclip -selection clipboard'.split(' '), stdin=temp_file)


    if process.returncode != 0:
        _error(f'Comando "xclip" retornou status não-zero ({process.returncode})', 1)


def main():
    global args

    args = parse_command_line()

    logger_wrapper.configure(args.verbosity)
    '''
    Logger reference: https://docs.python.org/3/library/logging.html
    '''
    global logger
    logger = logger_wrapper.get(__name__)

    with open(getConfigFile()) as f:
        import yaml

        configs = yaml.safe_load(f)

    request_args = getRequestArgs(args, configs)

    logger.debug(request_args)

    with requests.post(**request_args) as r:

        if r.status_code != 200:
            _error(f'Fazendo request: {r.text}', 1)

        response_body = r.json()

    token = response_body['access_token']

    copy_to_clipboard(token)

    print('Token copiado para a área de transferência')


if __name__ == '__main__':
    main()

